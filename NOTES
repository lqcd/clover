

/* Allocate count "fermions":
   returns pointer for qx(free)(),
   and a pointer to fermion vector in fv.
   If not memory, returns NULL
 */
void *qx(allocate_fv)(
        struct Q(State) *state,
        int dim,
        struct vFermion **fv, int fv_size
        );

void qx(free_fv)();

/*
 * set fv[idx] = x
*/
unsigned int qx(fv_put)(
        int dim,
        struct vFermion *fv, int fv_size, int fv_idx,
        const struct Fermion *x
        );

/*
 * read x = fv[idx]
*/
unsigned int qx(fv_get)(
        int dim,
        struct Fermion *x,
        const struct vFermion *fv, int fv_size, int fv_idx
        );

/* fv[fv_begin + (0 .. len-1)] = gv[gv_begin + (0 .. len-1)]
*/
unsigned int qx(fv_copy)(
        int dim, int len,
        struct vFermion *fv, int fv_size, int fv_begin,
        const struct vFermion *gv, int gv_size, int gv_begin
        );

/*
*   g = fv[fv_begin + (0 .. f_vlen-1)] . v
*   v is a complex vector [fv_len] indexed as [re:0/im:1 + 2 * i]
*/
unsigned int qx(fv_dot_zv)(
        int dim,
        struct Fermion *g,
        const struct vFermion *fv, int fv_size, int fv_begin, int fv_len,
        const double *v
        );

/*
*   gv[gv_begin + (0 .. gv_len-1)] = m[gv_len*fv_len] . fv[fv_begin + (0 .. f_len - 1)]
*   m is a double matrix [fv_len*gv_len] indexed as [ row + ldm * col ]
*/
unsigned int qx(fv_dot_dm)(
        int dim, 
        struct vFermion *gv, int gv_row_size, int gv_begin, int gv_len,
        const struct vFermion *fv, int fv_row_size, int fv_begin, int fv_len,
        const double *m, int ldm
        );

/*
*   gv[gv_begin + (0 .. gv_len-1)] = fv[fv_begin + (0 .. f_len - 1)] . m
*   m is a complex matrix [fv_len*gv_len] indexed as [re:0/im:1 + 2 * (row + ldm * col) ]
*/
unsigned int qx(fv_dot_zm)(
        int dim,
        struct vFermion *gv, int gv_row_size, int gv_begin, int gv_len,
        const struct vFermion *fv, int fv_row_size, int fv_begin, int fv_len,
        const double *m, int ldm
        );

/*  XXX this includes global reduction
 *  c[i] = herm(fv[fv_begin+i]) * g 
 *      for all i = (0 .. fv_len-1)
 *  c is complex vector as [re:0/im:1 + 2 * i]
 */
unsigned int qx(fvH_dot_f)(
        int dim,
        double *c,
        const struct vFermion *fv, int fv_size, int fv_begin, int fv_len,
        const struct Fermion *g
        );
//This is a local op, see port/fermion-dot.c for computing the global norm

/* XXX this includes global reduction
 * c[i,j] = herm(fv[fv_begin + i]) . g[gv_begin+j] 
 *      for all i = (0 .. fv_len-1), 
 *              j = (0 .. gv_len-1),
 * c is a complex matrix as [re:0/im:1 + 2 * (i + ldc * j)]
 */
unsigned int qx(fvH_dot_fv)(
        int dim,
        double *c, int ldc,
        const struct vFermion *fv, int fv_size, int fv_begin, int fv_len,
        const struct vFermion *gv, int gv_size, int gv_begin, int gv_len
        );
//This is a local op, see port/fermion-dot.c for computing the global norm




/* ADDED BY SNS (I believe there are equivalents; just rename any occurrence in the code): */
/* copy single-prec vector  f <- f_src */
unsigned int qx(f_copy_cc)(
        int dim,
        struct FermionF *f, const struct FermionF *f_src);
/* f <-  f * alpha */
unsigned int qx(f_scal_cd)(
        int dim,
        struct FermionF *f, double alpha);
/*  */


//EXIST:
//unsigned int qx(f_norm)(double *s,
//                        int size,
//                        const struct Fermion *a);
unsigned int qop_f3_clover_f_norm(double *s,
                                  int size,
                                  const struct FermionF *a);
unsigned int qop_d3_clover_f_norm(double *s,
                                  int size,
                                  const struct FermionD *a);

/* r = a + s * b */
unsigned int qx(f_add3)(struct Fermion *r,
                        int size,
                        const struct Fermion *a,
                        double s,
                        const struct Fermion *b);

/* r += s * b */
unsigned int qx(f_add2)(struct Fermion *r,
                        int size,
                        double s,
                        const struct Fermion *b);

/* memory allocation */
void *q(malloc)(struct Q(State) *state, size_t bytes);
void q(free)(struct Q(State) *state, void *ptr, size_t bytes);

//This is a local op, see port/cg-solver.c for computing the global norm,
//but use QMP_sum_double_array() instead.
